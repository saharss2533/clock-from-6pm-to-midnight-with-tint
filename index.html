<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>6pm → Midnight (6 min) · White Clock, Black Hand, Sky Blend</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: rgba(0,0,0,0); /* fully transparent page */
    }
    /* Fullscreen background canvas */
    #bg {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: transparent;
      pointer-events: none;
      z-index: 0;
    }
    /* Clock canvas pinned top-left */
    #clock {
      position: fixed;
      top: 0;
      left: 0;
      width: 120px;
      height: 120px;
      background: transparent;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <canvas id="clock" width="160" height="160"></canvas>

  <script>
    // ===== Config =====
    const BG_ALPHA = 0.2; // subtle but visible background

    // Colors inspired by Vancouver August:
    const SKY_6PM      = { r: 255, g: 196, b: 140 }; // warm late afternoon ~ #FFC48C
    const SKY_MIDNIGHT = { r: 13,  g: 27,  b: 58  }; // deep navy ~ #0D1B3A

    const DURATION = 6 * 60 * 1000; // 6 minutes total

    // Angles: 6pm → midnight (6 hours = 180°)
    const startAngle = (-Math.PI / 2) + 6 * (Math.PI / 6); // 12 o'clock + 6 hours = pointing down
    const endAngle   = startAngle + Math.PI;               // +6 hours → back to 12 o'clock (midnight)

    const bg = document.getElementById('bg');
    const clock = document.getElementById('clock');
    const bgCtx = bg.getContext('2d');
    const clockCtx = clock.getContext('2d');

    // HiDPI helper
    function fitForDPR(canvas, ctx) {
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      if (canvas.width !== cssW * dpr || canvas.height !== cssH * dpr) {
        canvas.width = cssW * dpr;
        canvas.height = cssH * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }

    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp01 = x => Math.max(0, Math.min(1, x));
    const easeInOutQuad = t => (t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2);

    // Background blend: 6pm → midnight
    function renderBackground(t) {
      fitForDPR(bg, bgCtx);
      const w = bg.clientWidth, h = bg.clientHeight;

      const te = easeInOutQuad(clamp01(t));
      const r = Math.round(lerp(SKY_6PM.r,  SKY_MIDNIGHT.r,  te));
      const g = Math.round(lerp(SKY_6PM.g,  SKY_MIDNIGHT.g,  te));
      const b = Math.round(lerp(SKY_6PM.b,  SKY_MIDNIGHT.b,  te));

      bgCtx.clearRect(0, 0, w, h);
      bgCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${BG_ALPHA})`;
      bgCtx.fillRect(0, 0, w, h);
    }

    // Clock face (white) + hand (black)
    function renderClock(angle) {
      fitForDPR(clock, clockCtx);
      const w = clock.clientWidth, h = clock.clientHeight;
      const cx = w / 2, cy = h / 2;
      const r = Math.min(w, h) * 0.45;

      clockCtx.clearRect(0, 0, w, h);

      // White clock face
      clockCtx.beginPath();
      clockCtx.arc(cx, cy, r, 0, Math.PI * 2);
      clockCtx.fillStyle = '#fff';
      clockCtx.fill();

      // Black hand
      clockCtx.beginPath();
      clockCtx.moveTo(cx, cy);
      clockCtx.lineTo(cx + r * 0.9 * Math.cos(angle), cy + r * 0.9 * Math.sin(angle));
      clockCtx.lineWidth = 3;
      clockCtx.lineCap = 'round';
      clockCtx.strokeStyle = '#000';
      clockCtx.stroke();

      // Black center pin
      clockCtx.beginPath();
      clockCtx.arc(cx, cy, 3, 0, Math.PI * 2);
      clockCtx.fillStyle = '#000';
      clockCtx.fill();
    }

    // Animation
    let startTime;
    function loop(ts) {
      if (!startTime) startTime = ts;
      const elapsed = ts - startTime;
      const t = Math.min(elapsed / DURATION, 1); // 0..1

      renderBackground(t);
      const angle = startAngle + t * (endAngle - startAngle);
      renderClock(angle);

      if (t < 1) requestAnimationFrame(loop); // stop at midnight
    }

    window.addEventListener('resize', () => {
      fitForDPR(bg, bgCtx);
      fitForDPR(clock, clockCtx);
    });

    requestAnimationFrame(loop);
  </script>
</body>
</html>
